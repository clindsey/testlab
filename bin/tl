#!/usr/bin/env ruby
################################################################################
#
#      Author: Zachary Patten <zachary AT jovelabs DOT com>
#   Copyright: Copyright (c) Zachary Patten
#     License: Apache License, Version 2.0
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
################################################################################
require 'gli'
require 'testlab'

include GLI::App
include TestLab::Utility::Misc

version TestLab::VERSION

program_desc %(TestLab - A toolkit for building virtual computer labs)
# program_long_desc %(Program Long Description)

sort_help :manually
default_command :help

commands_from File.join(File.dirname(__FILE__), 'commands')

desc 'Show verbose output'
default_value false
switch [:v, :verbose]

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only

  if !global[:v].nil?
    ENV['LOG_LEVEL'] = 'DEBUG'
  end

  log_file = File.join(Dir.pwd, "testlab.log")
  @logger = ZTK::Logger.new(log_file)

  TestLab::Utility.log_header.each { |line| @logger.info { line } }

  @logger.debug { "global(#{global.inspect})" }
  @logger.debug { "options(#{options.inspect})" }
  @logger.debug { "args(#{args.inspect})" }

  @ui = ZTK::UI.new(:logger => @logger)
  @testlab = TestLab.new(:ui => @ui)

  message = format_message("TestLab v#{TestLab::VERSION} Loaded".black.bold)
  @testlab.ui.stdout.puts(message)

  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  @ui.stderr.puts
  @ui.stderr.puts(format_message(["ERROR:".red, exception.message.red.bold].join(' ')))

  case exception
  when GLI::BadCommandLine, GLI::UnknownCommand, GLI::UnknownCommandArgument, GLI::UnknownGlobalArgument then
    command_regex = /Command '([\w]+)' /
    command = exception.message.scan(command_regex).flatten.first

    @ui.stderr.puts
    commands[:help] and commands[:help].execute({}, {}, (command.nil? ? [] : [command.to_s]))

    false
  else
    @logger.fatal { exception.inspect }
    exception.backtrace.each do |line|
      @logger.logdev.write("#{line}\n")
    end

    false
  end
end

exit run(ARGV)
