#!/usr/bin/env ruby
################################################################################
#
#      Author: Zachary Patten <zachary AT jovelabs DOT com>
#   Copyright: Copyright (c) Zachary Patten
#     License: Apache License, Version 2.0
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
################################################################################
require 'gli'
require 'ztk'
require 'testlab'

include GLI::App
include TestLab::Utility::Misc

LAB_ACTIONS = %W(create destroy up down setup teardown build demolish).map(&:to_sym)
LAB_ACTIONS_DESC = {
  :create   => ["Construct %s",    "Attempts to create the <%= @component %>."],
  :destroy  => ["Destruct %s",     "Attempts to destroy the <%= @component %>."],
  :up       => ["On-line %s",      "Attempts to online the <%= @component %>."],
  :down     => ["Off-line %s",     "Attempts to offline the <%= @component %>."],
  :setup    => ["Provision %s",    "Attempts to provision the <%= @component %>."],
  :teardown => ["De-provision %s", "Attempts to deprovision the <%= @component %>."],
  :build    => ["Build %s", <<-EOF],
Attempts to build the <%= @component %>.  TestLab will attempt to create, online and provision the <%= @component %>.

The <%= @component %> are taken through the following states:

Create -> Up -> Setup
EOF
  :demolish => ["Demolish %s", <<-EOF]
Attempts to demolish the <%= @component %>.  TestLab will attempt to deprovision, offline and destroy the <%= @component %>.

The <%= @component %> are taken through the following states:

Teardown -> Down -> Destroy
EOF
}

def build_lab_commands(component, klass, &block)
  desc %(Manage lab #{component}s)
  command component do |c|
    c.desc %(Optional #{component} ID or comma separated list of #{component} IDs)
    c.arg_name %(#{component}[,#{component},...])
    c.flag [:n, :name]

    LAB_ACTIONS.each do |lab_action|
      c.desc(LAB_ACTIONS_DESC[lab_action].first % "#{component}s")
      c.long_desc(ZTK::Template.string(LAB_ACTIONS_DESC[lab_action].last, {:component => "#{component}s"}))

      c.command lab_action do |la|
        la.action do |global_options, options, args|
          iterate_objects_by_name(options[:name], klass) do |object|
            object.send(lab_action)
          end
        end
      end
    end

    !block.nil? and block.call(c)
  end
end

def iterate_objects_by_name(name, klass, &block)
  objects = Array.new
  klass_name = klass.to_s.split('::').last.downcase

  if name.nil?
    objects = klass.all
  else
    names = name.split(',')
    objects = klass.find(names)
  end

  (objects.nil? || (objects.count == 0)) and raise TestLab::TestLabError, "We could not find any of the #{klass_name}s you supplied!"

  objects.each do |object|
    !block.nil? and block.call(object)
  end

  objects
end

version TestLab::VERSION

program_desc %(TestLab - A toolkit for building virtual computer labs)
# program_long_desc %(Program Long Description)

sort_help :manually
default_command :help

preserve_argv true

commands_from 'commands'

desc 'Show verbose output'
default_value false
switch [:v, :verbose]

desc 'Quiet mode'
default_value false
switch [:q, :quiet]

desc 'Path to Labfile: ${REPO}/Labfile'
arg_name 'path/to/file'
# default_value File.join(Dir.pwd, 'Labfile')
flag [:l, :labfile]

desc 'Path to Repository directory: ${PWD}'
arg_name 'path/to/directory'
default_value Dir.pwd
flag [:r, :repo]

desc 'Path to Configuration directory: ${REPO}/.testlab-$(hostname -s)'
arg_name 'path/to/directory'
# default_value File.join(Dir.pwd, ".testlab-#{TestLab.hostname}")
flag [:c, :config]

pre do |global,command,options,args|
  (global[:verbose] == true) and (ENV['LOG_LEVEL'] = 'DEBUG')

  log_file = File.join(global[:repo], "testlab-#{TestLab.hostname}.log")
  @logger = ZTK::Logger.new(log_file)

  @ui = ZTK::UI.new(
    :logger  => @logger,
    :verbose => global[:verbose],
    :quiet   => global[:quiet]
  )

  @testlab = TestLab.new(
    :ui => @ui,
    :labfile_path => global[:labfile],
    :config_dir   => global[:config],
    :repo_dir     => global[:repo]
  )

  @ui.logger.debug { "global(#{global.inspect})" }
  @ui.logger.debug { "options(#{options.inspect})" }
  @ui.logger.debug { "args(#{args.inspect})" }

  TestLab::Utility.log_header(@testlab).each { |line| @logger.info { line } }

  if !@ui.quiet?
    message = format_message("TestLab v#{TestLab::VERSION} Loaded".black.bold)
    @testlab.ui.stdout.puts(message)
  end

  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  @ui.stderr.puts
  @ui.stderr.puts(format_message(["ERROR:".red, exception.message.red.bold].join(' ')))

  case exception
  when GLI::BadCommandLine, GLI::UnknownCommand, GLI::UnknownCommandArgument, GLI::UnknownGlobalArgument then
    command_regex = /Command '([\w]+)' /
    command = exception.message.scan(command_regex).flatten.first

    @ui.stderr.puts
    commands[:help] and commands[:help].execute({}, {}, (command.nil? ? [] : [command.to_s]))

    false
  else
    @logger.fatal { exception.inspect }
    exception.backtrace.each do |line|
      @logger.logdev.write("#{line}\n")
    end

    false
  end
end

exit run(ARGV)
